---
title: ScyllaDB å­¦ä¹ (ä¸€) -- smf
layout: post
excerpt: smf - the fastest RPC in the West
categories: ScyllaDB
---

{% include toc %}

å­¦ä¹  `ScyllaDB` ä¼šä» [`seastar`](http://seastar.io/) å…¥æ‰‹ï¼Œåœ¨è¿™ä¹‹å‰å…ˆå­¦ä¹ ä¸‹ [`smf`](https://github.com/smfrpc/smf/tree/5cb511999becf0f66b66a8fcfd2679d9fda79983)ï¼Œå®ƒæ˜¯ç”¨ `seastar` å®ç°çš„ RPC æ¡†æ¶ï¼Œå·ç§°è¥¿åŠçƒæœ€å¿« RPCã€‚

## RPC æ¡†æ¶å®ç°

å®ç°æœ€åŸºç¡€çš„ RPC æ¡†æ¶è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œä»ä¸Šåˆ°ä¸‹çš„è¯å¤§æ¦‚åˆ†ä¸ºè¿™å‡ æ­¥ï¼š

1. æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚ã€æœåŠ¡ï¼šç°åœ¨çš„ RPC æ¡†æ¶å¤§éƒ½ä½¿ç”¨ä»£ç ç”Ÿæˆï¼Œç”¨æˆ·åªè¦æ ¹æ®åè®®å®šä¹‰å¥½ç±»å‹å’Œæ¥å£å³å¯ï¼ŒRPC æ¡†æ¶ä¼šç”Ÿæˆå¥½å¯¹åº”çš„ç±»ã€å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ã€‚ç±»å‹é€šå¸¸ä½¿ç”¨ç°æˆçš„åºåˆ—åŒ–åº“ï¼Œæ¯”å¦‚ [`protobuf`](https://github.com/protocolbuffers/protobuf)ã€‚å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„ä»£ç ç”Ÿæˆè¦ç”± RPC æ¡†æ¶è‡ªå·±å†™ï¼Œå› ä¸ºéœ€è¦ä¾èµ–æ¡†æ¶çš„å†…éƒ¨å®ç°ï¼Œæ¯”å¦‚æ¡†æ¶é€šå¸¸éƒ½ä¼šæœ‰ä¸€ä¸ª client åŸºç±»ï¼ŒåŠŸèƒ½æ˜¯å‘é€å„ç§è¯·æ±‚ç»™æœåŠ¡ç«¯ï¼Œè€Œç”Ÿæˆçš„å®¢æˆ·ç«¯å°±ä¼šç»§æ‰¿è¿™ä¸ªåŸºç±»ï¼Œå¹¶åœ¨æ­¤ä¹‹ä¸Šæä¾›å¼ºç±»å‹çš„ã€ç”¨æˆ·å®šä¹‰å¥½çš„æ¥å£ã€‚å®¢æˆ·ç«¯æ˜¯æ‹¿æ¥å³ç”¨çš„ï¼Œè€ŒæœåŠ¡ç«¯ä¸€èˆ¬ä¹Ÿæ˜¯ä¸ªåŸºç±»ï¼Œéœ€è¦ç”¨æˆ·å®ç°å®šä¹‰å¥½çš„æ¥å£ã€‚
2. é€šä¿¡åè®®ï¼šæœ€åŸºæœ¬çš„è¦æ±‚åŒ…æ‹¬ä¸¤éƒ¨åˆ†ï¼Œä¸€æ˜¯ç±»å‹çš„åºåˆ—åŒ–ï¼Œè¿™ç”±åºåˆ—åŒ–åº“è§£å†³äº†ï¼›äºŒæ˜¯æ‰¾åˆ°è¦è°ƒç”¨çš„æ¥å£ï¼Œæ¯”å¦‚æ¯ä¸ªæ¥å£éƒ½æœ‰ä¸€ä¸ª UUIDï¼Œå®¢æˆ·ç«¯å‘è¯·æ±‚å°±ä¼šå¸¦ç€å®ƒï¼ŒæœåŠ¡ç«¯æ”¶åˆ°åå°±é€šè¿‡ UUID æ‰¾åˆ°å¯¹åº”çš„æ¥å£å†è°ƒç”¨ã€‚ä»¥ `gRPC` ä¸ºä¾‹ï¼Œå®ƒçš„åŠŸèƒ½æ¯”è¾ƒå¤šï¼Œåè®®ç”¨çš„æ˜¯ `HTTP/2`ï¼Œæ¥å£çš„ UUID æ˜¯ `/{service name}/{method name}`ã€‚
3. ç½‘ç»œæ¡†æ¶ï¼šè´Ÿè´£æ•°æ®çš„æ”¶å‘ï¼Œæ²¡å•¥å¥½è¯´çš„ï¼Œä¸»è¦å…³æ³¨å®ƒçš„æ€§èƒ½ï¼Œä¹Ÿæ˜¯è¿™æ¬¡çš„é‡ç‚¹ã€‚

## smf å®ç°

### è‡ªå®šä¹‰è¯·æ±‚ã€æœåŠ¡

`smf` åºåˆ—åŒ–ç”¨çš„æ˜¯ [`FlatBuffers`](https://github.com/google/flatbuffers)ï¼Œä¹‹å‰æ²¡å¬è¯´è¿‡ï¼ˆå­¤é™‹å¯¡é—»äº†ï¼‰ï¼Œçœ‹äº†ä¸‹ä»‹ç»è¯´æœ€å¤§çš„äº®ç‚¹æ˜¯ä¸éœ€è¦ååºåˆ—åŒ–å°±èƒ½è®¿é—®æ•°æ®ï¼Œé‚£ç›²çŒœåºåˆ—åŒ–æ˜¯ç›´æ¥æŠŠå†…å­˜ç»“æ„ä¿å­˜ä¸‹æ¥äº†ï¼Œæ‰€ä»¥å°±ä¸éœ€è¦ååºåˆ—ï¼Œä» [benchmark](https://google.github.io/flatbuffers/flatbuffers_benchmarks.html) ç»“æœçœ‹ï¼Œæ€§èƒ½ç¡®å®å¾ˆå¥½ï¼Œåºåˆ—åŒ–åçš„å¤§å°ç¡®å®æ¯” raw struct è¿˜å¤§ä¸€äº›ï¼Œåº”è¯¥åŠ äº† header è®°å½• offset ä¹‹ç±»çš„ã€‚å®ƒä¹Ÿæ”¯æŒå‘å‰/åå…¼å®¹ï¼Œä¸äº†è§£æ”¯æŒåˆ°å“ªç§ç¨‹åº¦ï¼Œåº”è¯¥æ˜¯åœ¨ header ä¸Šåšäº†äº›æ–‡ç« ã€‚

ä»£ç ç”Ÿæˆå™¨å°±æ˜¯æŒ‰ç…§å›ºå®šçš„æ¡†æ¶ç”Ÿæˆä»£ç ï¼Œå°±ä¸ä»‹ç»å®ç°äº†ï¼Œåªçœ‹çœ‹ç”Ÿæˆçš„ä»£ç æ˜¯ä»€ä¹ˆæ ·çš„ã€‚ç”Ÿæˆçš„ service ä¼šç»§æ‰¿ `smf::rpc_service`ï¼Œå¹¶ä¸”å®šä¹‰å¥½å„ä¸ªæ¥å£çš„é»˜è®¤å®ç°ï¼Œç”¨æˆ·éœ€è¦ç»§æ‰¿è¿™ä¸ª service æ¥å®ç°è‡ªå·±çš„é€»è¾‘ï¼Œå†æ³¨å†Œåˆ° `smf::rpc_server` é‡Œä½¿ç”¨ã€‚`smf::rpc_service` å®šä¹‰å¦‚ä¸‹ï¼Œä»å®šä¹‰å°±èƒ½çŒœå‡ºæ¥ `smf::rpc_server` æ˜¯æ€ä¹ˆå¤„ç†è¯·æ±‚äº†ï¼šè¯·æ±‚é‡Œä¼šå¸¦ç€ `uint32_t` çš„ request IDï¼Œserver éå†æ³¨å†Œçš„ service æ‰¾åˆ°å¯¹åº”çš„ method æ¥è°ƒç”¨ã€‚

```cpp
struct rpc_service {
  virtual const char *service_name() const = 0;
  virtual uint32_t service_id() const = 0;
  virtual rpc_service_method_handle *method_for_request_id(uint32_t idx) = 0;
  virtual std::ostream &print(std::ostream &) const = 0;
  virtual ~rpc_service() {}
  rpc_service() {}
};
```

çœ‹ä»£ç ä¹Ÿç¡®å®æ˜¯è¿™æ ·ï¼Œ`smf::rpc_server` æŠŠæ³¨å†Œçš„ service ä¿å­˜åœ¨ vector é‡Œï¼Œéå†è°ƒç”¨ `method_for_request_id()` æ‰¾åˆ° method æ¥è°ƒç”¨ï¼Œ`method_for_request_id()` çš„å®ç°å°±æ˜¯ swtich-case ã€‚request ID çš„è®¡ç®—æ–¹å¼å¦‚ä¸‹ï¼š

* request ID = service ID ^ method ID
* service ID = crc32(service name)
* method ID = crc32(method name:input type name:output type name)ï¼Œå› ä¸º C++ æ”¯æŒé‡è½½ï¼Œæ‰€ä»¥å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ä¹Ÿä¼šç”¨æ¥è®¡ç®—ã€‚

`rpc_service_method_handle` é‡Œ method ç±»å‹å¦‚ä¸‹ï¼Œè¿™é‡Œå°±ä¸ä»‹ç» `seastar::future` äº†ã€‚å› ä¸º service çš„æ¥å£éƒ½æ˜¯å…·ä½“çš„ç±»å‹(`rpc_typed_envelope<T>`, `rpc_recv_typed_context<T>`)ï¼Œè€Œè¿™é‡Œéœ€è¦ç”¨ç»Ÿä¸€çš„ç±»å‹æ¥ä¿å­˜ï¼Œæ‰€ä»¥ç”¨çš„æ˜¯ä¿å­˜åºåˆ—åŒ–ä¹‹åæ•°æ®çš„ `rpc_recv_context` å’Œ `rpc_envelope` ç±»å‹ï¼Œè¿™é‡Œè¿”å›çš„ method ä¹Ÿå°±æ˜¯åœ¨ç”¨æˆ·å®ç°çš„æ¥å£ä¸Šå†åŒ…äº†ä¸€å±‚ç±»å‹è½¬æ¢çš„ã€‚

```cpp
using fn_t = seastar::noncopyable_function<seastar::future<rpc_envelope>(
  rpc_recv_context &&recv)>;
```

service ä»‹ç»å®Œå°±åˆ° client äº†ï¼Œç”Ÿæˆçš„ client ä¼šç»§æ‰¿ `smf::rpc_client`ï¼Œå®ƒæä¾›äº†å‘é€è¯·æ±‚&æ¥æ”¶å“åº”çš„åŠŸèƒ½ï¼Œç”Ÿæˆçš„ client å°±æ˜¯åœ¨å®ƒä¹‹ä¸ŠåŒ…äº†ä¸€å±‚æ¥æä¾›ç”¨æˆ·å®šä¹‰çš„æ¥å£ã€‚

### é€šä¿¡åè®®

`smf` çš„åè®®å°±æ˜¯åœ¨ `FlatBuffers` åºåˆ—åŒ–çš„ payload ä¹‹å‰å¢åŠ äº†å›ºå®šå¤§å°çš„ headerï¼Œheader çš„åºåˆ—åŒ–ä¹Ÿæ˜¯æŠŠå†…å­˜ç»“æ„ç›´æ¥ä¿å­˜ä¸‹æ¥äº†ï¼Œä¹Ÿæ²¡å¤„ç†å¤§å°ç«¯ä¹‹ç±»çš„ã€‚header æ ¼å¼å¦‚ä¸‹ï¼š

```cpp
/// layout
/// [ 8bits(compression) + 8bits(bitflags) + 16bits(session) + 32bits(size) + 32bits(checksum) + 32bits(meta) ]
/// total = 128bits == 16bytes
```

å®¢æˆ·ç«¯ä¼šåœ¨ `meta` é‡Œè®¾ç½®ä¸Šé¢æåˆ°çš„ request IDï¼ŒæœåŠ¡ç«¯ä¼šåœ¨ `meta` é‡Œè®¾ç½® HTTP status codeï¼›`size` æ˜¯ payload çš„å¤§å°ï¼›`session` åœ¨åé¢ä»‹ç»ï¼›`compression`/`checksum` çœ‹åå­—ä¹ŸçŸ¥é“ä½œç”¨ã€‚

### ç½‘ç»œæ¡†æ¶

åˆ°äº†è¿™æ¬¡çš„é‡ç‚¹ï¼Œç»“æœå‘ç°æ²¡ä»€ä¹ˆå¥½å†™çš„ï¼Œå…¨æ˜¯ `seastar` çš„åŠŸåŠ³ğŸ¤£ã€‚

#### æ•°æ®æ”¶å‘

å…ˆæ¥çœ‹æ•°æ®çš„æ”¶å‘ï¼Œåœ¨ä¸Šé¢ä¹Ÿæåˆ°äº†ç±»å‹è½¬æ¢ï¼Œå•å‘çš„ç±»å‹è½¬æ¢å¦‚ä¸‹ï¼š

* `rpc_typed_envelope<T>` -> `rpc_envelope` -> `rpc_recv_context ` -> `rpc_recv_typed_context<T>`

typed ç±»å‹æ˜¯åŒ…å«å…·ä½“ç±»å‹çš„ï¼Œåºåˆ—åŒ–åå°±æ˜¯ non-typed çš„ç±»å‹ï¼Œå‘æ•°æ®çš„å®ç°åœ¨ `rpc_envelope`ï¼Œæ”¶æ•°æ®åœ¨ `rpc_recv_context`ï¼Œå®ç°å°±æ˜¯è°ƒ `seastar` çš„æ–¹æ³•å…ˆå‘/æ”¶ header å†å‘/æ”¶ payloadï¼Œçœ‹ä»£ç å°±å¤Ÿäº†ï¼Œä¸ä»‹ç»äº†ã€‚

```cpp
seastar::future<>
rpc_envelope::send(seastar::output_stream<char> *out, rpc_envelope e) {
  ...
  return out->write(std::move(header_buf))
    .then([out, e = std::move(e)]() mutable {
      return out->write(std::move(e.letter.body));
    })
    .then([out] { return out->flush(); });
}

// rpc_recv_context::parse_payload() ç±»ä¼¼
seastar::future<std::optional<rpc::header>>
rpc_recv_context::parse_header(rpc_connection *conn) {
  ...
  return conn->istream.read_exactly(kRPCHeaderSize)
    .then([conn](seastar::temporary_buffer<char> header) {
      auto hdr = rpc::header();
      std::memcpy(&hdr, header.get(), kRPCHeaderSize);
      return seastar::make_ready_future<ret_type>(std::move(hdr));
    })
  ...
}
```

#### rpc_server

ç°åœ¨çœ‹ä¸‹ `rpc_server` æ˜¯å¦‚ä½•å¤„ç†è¿æ¥çš„ï¼Œ`rpc_server::start()` ä¼š spawn ä¸€ä¸ªä¸€ç›´æ¥æ”¶æ–°è¿æ¥çš„ futureï¼Œ`handle_client_connection()` ä¹Ÿæ˜¯ spawn å‡ºå»çš„ future æ‰€ä»¥æ˜¯å¼‚æ­¥å¤„ç†æ¯ä¸ªè¿æ¥çš„ã€‚

```cpp
void
rpc_server::start() {
  ...
  (void)seastar::keep_doing([this] {
    return listener_->accept().then([this, stats = stats_, limits = limits_](
                                      seastar::accept_result result) mutable {
      ...
      // DO NOT return the future. Need to execute in parallel
      (void)handle_client_connection(conn);
    });
  })
  ...
}
```

æ¯ä¸ªè¿æ¥çš„å¤„ç†æµç¨‹ç®€åŒ–ä¸‹æ¥å°±æ˜¯ `rpc_recv_context::parse_header()` -> `rpc_recv_context::parse_payload()` -> `method()` -> `rpc_envelope::send()` çš„ continuationï¼Œåä¸¤æ­¥ä¹Ÿæ˜¯åœ¨ spawn å‡ºå»çš„ future æ‰§è¡Œçš„ï¼Œæ‰€ä»¥å³ä½¿å•ä¸ªè¿æ¥ä¹Ÿæ˜¯æ”¯æŒå¹¶å‘è¯·æ±‚çš„ï¼Œä½†æ¯ä¸ªè¿æ¥åªæœ‰ä¸€ä¸ª socketï¼Œè‚¯å®šä¸èƒ½å¹¶å‘å‘æ¶ˆæ¯ï¼Œæ‰€ä»¥è¿™é‡Œç”¨äº† `seastar::semaphore serialize_writes{1}` æ¥ä¿è¯ä¸²è¡Œå‘é€ï¼š

```cpp
          return seastar::with_semaphore(
            conn->serialize_writes, 1, [conn, ee = std::move(e)]() mutable {
              return smf::rpc_envelope::send(&conn->conn.ostream,
                                             std::move(ee));
            });
```

#### rpc_client

`rpc_client` åŒç†ï¼Œä¸è¿‡æ˜¯åè¿‡æ¥çš„æµç¨‹ï¼Œå®ƒåŒæ ·æ”¯æŒå¹¶å‘å‘è¯·æ±‚ï¼Œä¹Ÿæ˜¯ç”¨ `seastar::semaphore` æ¥ä¸²è¡ŒåŒ–çš„ã€‚å› ä¸ºæ”¯æŒå¹¶å‘è¯·æ±‚ä¹Ÿæ„å‘³ç€ä¸èƒ½ä¿è¯å“åº”åˆ°è¾¾çš„é¡ºåºï¼Œæ‰€ä»¥ `rpc_client` ä¼šç»™æ¯ä¸ªè¯·æ±‚åœ¨ header é‡Œè®¾ç½® session IDï¼Œservice method ä¹Ÿä¼šç»™å“åº”è®¾ç½® session IDï¼Œè¿™æ ·å°±èƒ½ä¿è¯è¯·æ±‚å’Œå“åº”åŒ¹é…äº†ã€‚`rpc_client` å‘è¯·æ±‚æ—¶ç”¨ `unordered_map` ä¿å­˜äº†æ¯ä¸ªè¯·æ±‚çš„ `work_item`ï¼Œå‘è¯·æ±‚çš„ future å°±ä¼šé˜»å¡åœ¨ç­‰å¾… promise å®Œæˆï¼š`work->pr.get_future()`ã€‚

```cpp
  struct work_item {
    using promise_t = seastar::promise<std::optional<rpc_recv_context>>;
    ...
    promise_t pr;
    uint16_t session{0};
  };
```

`rpc_client` åœ¨è¿æ¥åˆ° server åä¼š spawn ä¸“é—¨è¯»å“åº”çš„ futureï¼Œæ¯æ”¶åˆ°å®Œæ•´çš„å“åº”åå°±ä¼šä» map é‡Œæ ¹æ® session ID æ‰¾åˆ°å¯¹åº”çš„ `work_item` å¹¶è®¾ç½® `seastar::promise` çš„å€¼ï¼Œä»è€Œå”¤é†’å¯¹åº”å‘è¯·æ±‚çš„ futureã€‚

```cpp
          uint16_t sess = opt->session();
          auto it = rpc_slots_.find(sess);
          ...
          it->second->pr.set_value(std::move(opt));
          rpc_slots_.erase(it);
```

### ä½¿ç”¨

`smf` å…¶å®å°±æ˜¯åŸºäº `seastar` å®ç°äº†æ”¯æŒ RPC çš„ futureï¼Œæ‰€ä»¥ä½¿ç”¨æ–¹å¼è¿˜æ˜¯éµå¾ª `seastar` çš„ã€‚server çš„å¯åŠ¨æ–¹å¼å¤§è‡´å¦‚ä¸‹ï¼Œæ„æ€æ˜¯åœ¨æ¯ä¸ª core ä¸Šéƒ½åˆ›å»º `smf::rpc_server`ï¼Œæ³¨å†Œ service å†å¯åŠ¨ã€‚

```cpp
  seastar::distributed<smf::rpc_server> rpc;
  seastar::app_template app;
  return app.run_deprecated(args, argv, [&] {
    return seastar::async([&] {
      rpc.start(args).get();
      rpc.invoke_on_all(&smf::rpc_server::register_service<storage_service>)
        .get();
      rpc.invoke_on_all(&smf::rpc_server::start).get();
    });
  });
```

## æ€»ç»“

`smf` å°±æ˜¯æœ€ç®€å•çš„ RPC å®ç°ï¼Œé«˜æ€§èƒ½å…¨ä¾èµ– `seastar`ï¼Œä» `smf` ä½¿ç”¨ `seastar` çš„æ–¹å¼çœ‹ï¼Œ`seastar` éå¸¸åƒè¿˜æ²¡ async/.await æ—¶æœŸçš„ Rust futureï¼Œæˆ‘è¦æ˜¯æ²¡ Rust ç»éªŒçš„è¯çœ‹èµ·æ¥è¿˜åƒåŠ›ç‚¹ï¼Œç°åœ¨çœ‹è¿˜è›®äº²åˆ‡çš„ã€‚ä¹‹åä¼šå¼€å§‹å­¦ä¹  `seastar`ã€‚